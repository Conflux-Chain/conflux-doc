/**
 * abi object
 * @var {Object}
 *
 * @example
 > contract.abiModel
 AbiModel {
  abi:
   { methods:
      { count: [AbiItemModel],
        '0x06661abd': [AbiItemModel],
        'count()': [AbiItemModel],
        inc: [AbiItemModel],
        '0x812600df': [AbiItemModel],
        'inc(uint256)': [AbiItemModel],
        contractConstructor: [AbiItemModel] },
     events: {} } }
 */
let abiModel;

/**
 * The address used for this contract instance.
 * All transactions generated by confluxWeb from this contract will contain this address as the "to".
 *
 * @var {string}
 *
 * @example
 > contract.address; // What you set when new contract.
 "0xf02dbcf0eff48e174ca59f1975a7b0042c4d02b7"
 */
let address;

/**
 * The default maximum gas provided for a transaction (gasLimit).
 *
 * @var {number}
 */
let defaultGas;

/**
 * The default gas price in drip to use for transactions.
 *
 * @var {number}
 */
let defaultGasPrice;

/**
 * Creates a transaction object for that method, which then can be called, send, estimated.
 * The methods of this smart contract are available through:
 - The name: myContract.methods.myMethod(123)
 - The name with parameters: myContract.methods['myMethod(uint256)'](123)
 - The signature: myContract.methods['0x58cf5f10'](123)
 * This allows calling functions with same name but different parameters from the JavaScript contract object.
 *
 * @var {Proxy}
 *
 * @example
 > contract.address;
 "0x079352147ce2de227af6fa963f603a35aed8e601"

 > await contract.methods.count().call();
 BigNumber { _hex: '0xfe' }

 > await contract.methods.inc(1).call(); // call will get function return value
 BigNumber { _hex: '0xff' }

 > await contract.methods.count().call(); // can not change data in block chain by `call`
 BigNumber { _hex: '0xfe' }

 > await contract.methods.inc(1).send({
    from: '0xbbd9e9be525ab967e633bcdaeac8bd5723ed4d6b',
    gas: 100000000,
    gasPrice: 100
  }); // send a transaction
 "0xa3b0ca9cfbbdc624db53fc5df39849560ffa2d952b7e9af894524d45479cfa0a"
 > await confluxWeb.cfx.getTransactionReceipt('0xa3b0ca9cfbbdc624db53fc5df39849560ffa2d952b7e9af894524d45479cfa0a');
 {
   status: true,
   ...
 }
 > await contract.methods.count().call(); // change data in block chain by `send`
 BigNumber { _hex: '0xff' }
 */
let methods;

/**
 * Creates a new contract instance with all its methods and events defined in its json interface abi object.
 *
 * @param abi {object|array} - The abi json interface of the contract.
 * @param [address] {string} - The address where the contract is deployed. If undefined, you should deploy contract by data.
 * @param [options] {object}
 * @param [options.data] {string} - The byte code of the contract. Used when the contract gets deployed.
 * @param [options.from] {string} - The address transactions should be made from.
 * @param [options.gasPrice] {string} - The gas price in drip to use for transactions.
 * @param [options.gas] {number} - The maximum gas provided for a transaction (gasLimit).
 *
 * @example
 > confluxWeb.cfx.accounts.wallet.add('0xa816a06117e572ca7ae2f786a046d2bc478051d0717bf5cc4f5397923258d393'); // KEY
 > const contract = new confluxWeb.cfx.Contract(
 [
 {
        "constant": true,
        "inputs": [],
        "name": "count",
        "outputs": [
          {
            "internalType": "uint256",
            "name": "",
            "type": "uint256"
          }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
      },
 {
        "constant": false,
        "inputs": [
          {
            "internalType": "uint256",
            "name": "num",
            "type": "uint256"
          }
        ],
        "name": "inc",
        "outputs": [
          {
            "internalType": "uint256",
            "name": "",
            "type": "uint256"
          }
        ],
        "payable": false,
        "stateMutability": "nonpayable",
        "type": "function"
       },
 {
        "inputs": [
          {
            "internalType": "uint256",
            "name": "num",
            "type": "uint256"
          }
        ],
        "payable": false,
        "stateMutability": "nonpayable",
        "type": "constructor"
      }
 ],
 );
 */
function constructor(abi, address, options) {}

/**
 *
 * @param options {object}
 * @param [options.data] {string} contract data
 * @param [options.arguments] {array} contract constructor parameters
 * @return {Object}
 *
 * @example
 > await contract.deploy({arguments: [254]}).send({
    from: '0xbbd9e9be525ab967e633bcdaeac8bd5723ed4d6b',
    gas: 100000000,
    gasPrice: 819
 }); // deploy contract by `send`
 "0x6d1b5d68540faac893e5d5dcfed7fc253a2fd6936634f917c82856a0b19c3838"

 > await confluxWeb.cfx.getTransactionReceipt('0xd1d5b66b0d3d215f042f3e4907a3bf0acf5984972527fbca45eb67286835260d');
 {
   status: true,
   contractCreated: '0x079352147ce2de227af6fa963f603a35aed8e601',
   ...
 }

 > contract.address = '0x079352147ce2de227af6fa963f603a35aed8e601'; // after deploy, you should add address to contract
 */
function deploy(options) {}

/**
 * Clones the current contract instance.
 *
 * @return {Object} The new contract instance.
 * @example
 > const clone = contract.clone()
 > contract.defaultGas === clone.defaultGas;
 true

 > contract.defaultGasPrice === clone.defaultGasPrice;
 true

 > contract.address === clone.address; // only address difference, and clone one address to be undefined
 false
 */
function clone() {}
